---
title: "Stars 1"
author: "Walter Humberto Subiza Pina"
date: "11/16/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Presentando "stars"

tesselation = mosaico

En 2018, el tratamiento y manipulación de dados georreferenciados de tipo vectorial em _R_ fue revolucionado con el lanzamiento de **Pebesma E (2018) Simple features for R: standardized support for spatial vector data. R J 10(1):439–446** y la consecuente biblioteca _**sf**_ que implementaba los conceptos introducidos. 

De forma concisa se puede decir que la nueva propuesta, era que los dados espaciales vectoriales pueden ser representados por un dataframe, en el cual se incluye una nueva coluna de tipo _lista_, que contiene la geometria del objeto a representar. 

Los objetos creados son de la classe _sf_ o _simple features_ (ver documentación de la biblioteca _**sf**_). Al tratar los objetos espaciales como dataframe, se permite que sus columnas o atributos, sean facilmente manipulados y extraídos sin perder el georreferenciamiento en el proceso.   

Los archivos o datos de tipo raster por otro lado no estaban todavia contemplados, por lo que el análisis espacial em _R_ se completaba con la biblioteca _**raster**_. 

Asi fué hecho por ejemplo, el curso **Introdução ao Análise Espacial** <https://github.com/HumbertoSubiza/Intro_analise_espacial_R>  (en idioma portugués), ofrecido en el Instituto Brasileiro de Geografia e Estatística en Rio de Janeiro, Brasil en 2019.

Sin embargo, el concepto de tener una biblioteca única para el tratamiento de todo tipo de dato espacial continuaba a ser elaborada y así surge la biblioteca _**stars**_. .... CONTINUAR

Esta biblioteca introduce otro concepto nuevo, el de _datacubes array_, que podria ser traducido como arreglo cúbico de dados (una sugerencia) y donde la altura del cubo viene dada por múltiples dimensiones (o atributos).

Asi, el menor archivo raster tiene dos dimensiones espaciales representando la localización por ejemplo y un atributo que es el tipo de dado de la capa (layer). En la figura a seguir se representa um arreglo cúbido de cinco dimensiones.

![**Cinco dimensiones: longitud, latitud, tiempo, banda y sensor**](https://raw.githubusercontent.com/r-spatial/stars/master/images/cube2.png)

---

Cuando la biblioteca _**stars**_ es cargada en el ambiente _R_, trae consigo 2 bibliotecas auxiliares ( _abind_ e _sf_) y se conecta  con 3 más, que son:

  1. abind, para tratamiento de arreglos multi-dimensionales;
  
  2. sf, biblioteca para objetos georreferenciados del tipo vectorial;
  
  3. GEOS- _rgeos_, manipulación de la geometria de los elementos georreferenciados;
  
  4. GDAL- _rgadal_, para transformación de formatos vectoriales y raster;
  
  5. PROJ- _proj4_, interfase para transformación de sistemas de coordenadas geográficas en sistema de coordenadas proyectadas.


```{r}
library(stars)
```

---

Los objetos creados por esta nueva biblioteca pertenecen a una nueva clase, denominada **stars** y que al dia de hoy tiene los siguientes métodos disponibles:  

```{r}
methods(class = "stars")
```


### 2. Recordando arreglos (arrays)

Antes de continuar, es útil recordar el concepto y manejo de arreglos en _R_.

**Arreglos son objetos con una estrutura que permite almacenar datos multi-dimensionales.** 

Como ejemplo, matrices y dataframes pueden contener líneas y columnas de datos, la diferencia con arreglos es que éste puede tener mas de 1 dimensión, de ahi a visualización como cubos o capas superpuestas. Como limitación los datos contenidos en cada dimensión debem ser del mismo tipo

Veamos algunos ejemplos. Creamos um arreglo de 4 x 4 con tres dimensiones, a partir de dos vectores numéricos.

```{r}
vector1 =  c (1, 2, 3,4) # primero vector con 4 números
vector2 =  c (5, 6, 7, 8, 9, 10, 11, 12) # segundo vector con 8 números
col.nombres <- c("col1","col2","col3","col4")
lin.nombres <- c("lin1","lin2","lin3","lin4")
matriz.nombres <- c("M1","M2","M3")
cubo = array (c(vector1, vector2), # creación del arreglo
              dim = c (4, 4, 3),# determinando el tamaño y dimensiones
              dimnames = list(lin.nombres, col.nombres, matriz.nombres))

cubo                                # visualización
```

Vemos en la visualización, la notacion de arreglos y tres capas llamadas de M1, M2 y M3. El objeto creado es solamente de la clase _array_. La extracción de dados usando el operador "[", es simple. siguiendo el orden linea, columna, dimensión.

```{r}
(M2 <- cubo[ , ,2]) # segunda capa o dimensión
(M3_sub <- cubo[1:2, 2:4, 3]) # lineas 1 y 2, columnas 2 a 4 de la tercera dimensión
               
```

Veremos mas adelante otras formas de extrair datos, usando funciones específicas de la biblioteca, que poseem pequeñas diferencias con las presentadas.

---

La biblioteca maneja tambien datos vectoriales, del tipo punto o poligono, siendo éstos de una dimension espacial.

La conversion entre raster y vector es posible usando funciones especificas que veremos mas adelante.

Los datos vectoriales son tratados como _simple features_ y todas las funciones del ambiente tidyverse están disponibles para su manipulacion.

![Datos vectoriales em stars](https://raw.githubusercontent.com/r-spatial/stars/master/images/cube3.png)

### Lectura de datos

Un archivo raster puede ser leído de un directorio externo al ambiente usando la función _read_stars()_, en donde ser requiere un único argumento del tipo texto, indicando el camino hasta él, o puede ser convertido al formato _**stars**_, si ya está dentro de las variables de ambiente a través de la función _st_as_stars()_.
 
La biblioteca permite trabajar con dados en mallas regular o irregulamente espaciadas, así como con proyecciones geográficas o curvilíneas.

Para simplificar vamos leer um archivo raster de ejemplo, que la propia biblioteca incluye. El archivo es uma imagem Landsat 7 ETM, con 6 bandas, azul, verde, rojo y 3 más de infrarrojo, em formato Geotiff. La importación hará uso de la biblioteca GDAL

```{r}
tif = system.file("tif/L7_ETMs.tif", package = "stars")# creacion del camino del archivo como objeto texto

img = read_stars(tif) # leitura del archivo

plot(img, axes = T)
```

---

### 3. Explorando el objeto

```{r}
img
```

Vemos que el objeto creado tiene 3 dimensiones, siendo éstas _x_, _y_ e _band_ y 1 atributo que son los valores de cada banda. A continuación presenta las estadísticas de los valores del atributo para la totalidad del archivo.

Por último muestra los componentes de cada dimensión, siendo:


|campo   |	significado         |
|:--------|:----------------------|
|from    | origen del indice (i = 1)  |
|to	     |indice final (dim(x)[i])|
|offset  |valor inicial del pixel (si objeto regular)|
|delta	 |tamaño del intervalo de pixel o célula, (si objeto regular)|
|refsys	 |sistema geodésico de referencia en formato proj4|
|point	 |valor lógico; las células son puntos (T) o intervalos (F)|
|values	 |secuencia de valores (ex. geometries),se irregular|

En el caso específico de la imagen importada los valores de _x_ son un total de 349 y de _y_ 352, comenzando por los valores de 288776 para el eje _x_ y de 9120761 para _y_. El sistema de referencia es UTM zona 25S y los intervalos entre cada célula de 28,5 m y -28,5 m respectivamente. La imagen corresponde a um raster (point = F) del área de Recife, Brasil.

La referencia espacial para los indices está dada por la esquina superior izquierda de cada célula o pixel, siendo la primera célula la que está localizada en la esquina superior izquierda. El índice se cuenta de izquierda a derecha y de la parte superior a la inferior, si deseamos valores al centro de la célula precisamos agregar la mitad del intervalo o delta al valor a calcular.

La fórmula para el cálculo del valor de cada célula seria $$v = offset + (i−1) × delta$$. De esta forma el valor para la célula *v(15, 20)* seria: $$v_{x_{15}} = 288776 + (15-1)~ X~ 28.5 = 289175$$ y $$v_{y_{20}} = 9120761 + (20-1)~ X~ -28.5 = 9120220$$.

Para valores al centro de la célula, el delta debe ser aumentado em $14.3$.


### References

  https://r-spatial.github.io/stars/index.html

Leitura de archivo vectorial tipo ESRI por la biblioteca **sf**.

```{r}
library(sf)
olinda <- read_sf("C:/Users/Walter Pina/Documents/Github/spatial_stars/datos/olinda.shp")
olinda
plot(olinda["gid"], axes = T)
```

Transformación del objeto en clase **stars**.

```{r}
olinda_st <- st_as_stars(olinda)
olinda_st
plot(olinda_st["gid"], axes = T)
```




```{r}
#library(cubelyr)
#x %>% filter(x > 289000, x < 291000, y < 9120761, y > 9115061, band > 3) -> x7
```


